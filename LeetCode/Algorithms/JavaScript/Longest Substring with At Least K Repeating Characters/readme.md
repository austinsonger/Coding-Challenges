Firstly, I think of a way with the complexity of O(n^2). How to do? Just enum the item of the string s as the starting point of the substring, and you can preprocess some data, so that you can judge whether you should break a loop or not, at the some time you can update your maximum. 

For instance, `s = "ababbc" and k = 2`.  Take 0 as the starting point, it's an *a*, and you should have two *a* in the substring, so the length should be 3 at least. Then go on to the position 1, see a *b*, you should have two *b* too, so the length should be 4 at least( for the second *b* is in the fourth place). Then go to position 2, *a* has been considered about already, so skip it, 4 and 5 are both *b* that have been considered about, see the sixth position, it's a *c*, and there is just one *c* from sixth position, so you can decide that the maximum of substring starting from postion 0 is 5. See the code here [not-a-good-solution.js](https://github.com/hanzichi/leetcode/blob/master/Algorithms/Longest%20Substring%20with%20At%20Least%20K%20Repeating%20Characters/not-a-good-solution.js).

Above is not a good solution, for it will do some useless work. For instance, `s = "ababbcdefg" and k = 2`, when doing the first loop, you find the substring is *ababb*, then do the second from the position 1, but it seems needless, because when encountering the item *c*, you should break, but the substring will never longer then *ababb*.

So the better way is using **divide and conquer**. It's easy to understand, see the code [better-solution.js](https://github.com/hanzichi/leetcode/blob/master/Algorithms/Longest%20Substring%20with%20At%20Least%20K%20Repeating%20Characters/better-solution.js), and its complexity will be O(nlogn).